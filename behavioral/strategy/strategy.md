# 策略模式

策略模式只是定义了一个宏观的规则，内部具体算法可能各不相同。

``` go
package strategy

type Operator interface {
	Apply(int, int) int
}

type Operation struct {
	Operator Operator
}

func (o *Operation) Operate(leftValue, rightValue int) int {
	return o.Operator.Apply(leftValue, rightValue)
}
```

策略模式只是设计了一个包含一系列方法的接口。具体实现的方法是写一个带多个方法的接口和一个只包含此接口的抽象结构类型，接口中的每一个方法都为抽象结构添加相应的实现，其实现方法是调用接口带有的相应的方法。具体使用时，创建一个具体结构类型然后让它实现此接口，创建的具体结构实例可以给抽象结构赋值，若此时有多个具体结构类型，他们可以通过转换成抽象结构实现统一。

注意：要保证 Operator 接口中的方法与 Operation 结构带有的方法一致。

## 修饰者模式 与 策略模式

借用《head first 设计模式》中卖咖啡的修饰模式例子与维基百科中收税的策略模式例子对比一下。

修饰模式不会改变内部结构，只能在原有基础上扩充。经过不同修饰后他们的类型还是相同，但是各自的属性和方法不太一样，让他们能实现不同的方法。而策略模式只是定义了一个外部框架，内部属性方法却不同。内部不同的类型在策略这种模式下看起来是同一种类型。

例如，在卖咖啡的例子中，加牛奶的咖啡，加糖的咖啡，加牛奶和糖的咖啡本质上都是咖啡，所以定义了一个普通的咖啡方法得到普通咖啡，然后分别定义了加牛奶加糖两个方法，通过给普通咖啡修饰就可以得到不同种类的咖啡。虽然这几种咖啡实质都是普通咖啡，但是他们名字和价格都不一样，看起来是不同的。

而在收税的例子中，中国人美国人的税在需要纳的数目种类比例都不相同，但最终他们都是调用 Taxes()，虽然内部完全不同，但是最终形式结果保持同样，看起来是相同的。

适用范围：由咖啡的例子，咖啡的大部分属性共通，所以定义一个基本的咖啡类型，然后有的属性方法就添加进去，这就是修饰者模式的特点。由收税的例子，各国的税种不太一样而去算法不一样，基本上没法复用，不过可以让他们都具有收税等基本方法，所以可以让他们实现相同的接口，让他们调用同样的方法可以实现相同的功能，这就是策略模式的特点。

代码详见 **./compare/coffee** 与 **./compare/taxes** 